use anyhow::{bail, Result};
use colored::Colorize;
use indicatif::{MultiProgress, ProgressBar, ProgressStyle};

use crate::{
    config, git, github,
    state::{MergesState, Strategy},
};

pub async fn run(stacked: bool, independent: bool) -> Result<()> {
    let root = git::repo_root()?;
    let mut state = MergesState::load(&root)?;

    if state.chunks.is_empty() {
        bail!("No chunks defined. Run `merges split` first.");
    }

    // Determine strategy for this run
    let strategy = if stacked {
        Strategy::Stacked
    } else if independent {
        Strategy::Independent
    } else {
        state.strategy.clone()
    };

    println!(
        "{} Pushing {} chunk(s) as {} PRs",
        "→".blue().bold(),
        state.chunks.len().to_string().yellow(),
        format!("{}", strategy).cyan()
    );

    let token = config::github_token()?;
    let gh = github::client(&token)?;

    let current_branch = git::current_branch(&root)?;
    let mp = MultiProgress::new();
    let spinner_style = ProgressStyle::default_spinner()
        .template("{spinner} {msg}")
        .unwrap();

    for i in 0..state.chunks.len() {
        let chunk = state.chunks[i].clone();
        let pb = mp.add(ProgressBar::new_spinner());
        pb.set_style(spinner_style.clone());
        pb.enable_steady_tick(std::time::Duration::from_millis(80));
        pb.set_message(format!("Processing chunk '{}'…", chunk.name));

        // Switch to chunk branch and sync with base
        git::checkout(&root, &chunk.branch)?;
        pb.set_message(format!("[{}] Rebasing onto '{}'…", chunk.name, state.base_branch));
        match strategy {
            Strategy::Stacked => git::fetch_and_rebase_stacked(&root, &state.base_branch)?,
            Strategy::Independent => git::fetch_and_rebase(&root, &state.base_branch)?,
        }

        // Push
        pb.set_message(format!("[{}] Pushing…", chunk.name));
        git::push_branch(&root, &chunk.branch)?;

        // Determine base for this PR
        let pr_base = match strategy {
            Strategy::Stacked if i > 0 => state.chunks[i - 1].branch.clone(),
            _ => state.base_branch.clone(),
        };

        // Build PR body
        let files_list = chunk.files.iter().map(|f| format!("- `{}`", f)).collect::<Vec<_>>().join("\n");
        let body = format!(
            "## Chunk {}/{}: {}\n\n**Strategy:** {}\n\n### Files included\n{}\n\n---\n*Generated by [merges](https://github.com/merges-cli/merges)*",
            i + 1,
            state.chunks.len(),
            chunk.name,
            strategy,
            files_list
        );

        let title = format!(
            "[{}/{}] {}",
            i + 1,
            state.chunks.len(),
            chunk.name
        );

        if let Some(pr_number) = chunk.pr_number {
            // PR exists — update base if strategy changed
            pb.set_message(format!("[{}] Updating PR #{}…", chunk.name, pr_number));
            github::update_pr_base(&gh, &state.repo_owner, &state.repo_name, pr_number, &pr_base)
                .await?;
            pb.finish_with_message(format!(
                "{} [{}] PR #{} updated → {}",
                "✓".green(),
                chunk.name.cyan(),
                pr_number,
                chunk.pr_url.as_deref().unwrap_or("").dimmed()
            ));
        } else {
            // Create new PR
            pb.set_message(format!("[{}] Creating PR…", chunk.name));
            let (pr_number, pr_url) = github::create_pr(
                &gh,
                &state.repo_owner,
                &state.repo_name,
                &title,
                &chunk.branch,
                &pr_base,
                &body,
            )
            .await?;

            state.chunks[i].pr_number = Some(pr_number);
            state.chunks[i].pr_url = Some(pr_url.clone());
            state.strategy = strategy.clone();
            state.save(&root)?;

            pb.finish_with_message(format!(
                "{} [{}] PR #{} created → {}",
                "✓".green(),
                chunk.name.cyan(),
                pr_number,
                pr_url.dimmed()
            ));
        }
    }

    // Return to original branch
    git::checkout(&root, &current_branch)?;

    println!("\n{} All chunks pushed successfully!", "✓".green().bold());
    println!("  Run {} to see PR status.", "merges status".bold());

    Ok(())
}
